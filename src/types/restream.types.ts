export type Quality = "480p" | "720p" | "1080p";

export interface PlatformConfig {
  rtmpUrl: string;
  quality: Quality;
}

export interface PlatformStatus {
  running: boolean;
  retries: number;
}

export interface ServerStatus {
  message: string;
  active: boolean;
  platforms: {
    [key: string]: PlatformStatus;
  };
}

// // // NEW: Exported type for the start data payload
// // export interface StartStreamPayload {
// //   streamToYouTube: boolean;
// //   youtubeStreamKey?: string;
// //   streamToFacebook: boolean;
// //   facebookStreamKey?: string;
// //   quality: Quality;
// // }

// // // // Socket.IO event types
// // // export interface ServerToClientEvents {
// // //   status: (status: ServerStatus) => void;
// // //   error: (data: { message: string; fatal: boolean }) => void;
// // //   latency_response: (timestamp: number) => void;
// // //   restream_session: (data: { streamKey: string }) => void;
// // //   platform_status: (data: {
// // //   platform: 'youtube' | 'facebook';
// // //   status: 'idle' | 'live' | 'error';
// // //   message?: string;
// // // }) => void;
// // // }

// // // export interface ClientToServerEvents {
// // //   // The 'start' event takes a payload of type StartStreamPayload
// // //   start: (data: StartStreamPayload) => void;
// // //   stop: () => void;
// // //   media_chunk: (chunk: ArrayBuffer) => void;
// // //   latency_ping: (timestamp: number) => void;
// // //   start_preview: () => void;
// // //   stop_preview: () => void;
// // //   start_platform: (data: { platform: 'youtube' | 'facebook'; key: string }) => void;
// // //   stop_platform: (platform: 'youtube' | 'facebook') => void;
  
// // // }

// export interface StartStreamPayload {
//   streamToYouTube: boolean;
//   youtubeStreamKey?: string;
//   streamToFacebook: boolean;
//   facebookStreamKey?: string;
//   quality: Quality; // This might be less relevant for restreaming but good to keep
// }

// // Socket.IO event types
// export interface ServerToClientEvents {
//   status: (status: ServerStatus) => void;
//   error: (data: { message: string; fatal: boolean }) => void;
//   latency_response: (timestamp: number) => void;
//   // NEW: Event to provide the client with their unique stream key
//   restream_session: (data: { streamKey: string }) => void;
//   platform_status: (data: { platform: 'youtube' | 'facebook'; status: 'idle' | 'live' | 'error'; message?: string }) => void;
//   'restream:status': (data: {
//     status: 'idle' | 'live' | 'error';
//     platform?: string;
//     message: string;
//   }) => void;
//    restreamStatus: (status: 'previewing' | 'live' | 'stopped') => void;
//   restreamError: (message: string) => void;
// }

// export interface ClientToServerEvents {
//   start: (data: StartStreamPayload) => void;
//   stop: () => void;
//   media_chunk: (chunk: ArrayBuffer) => void;
//   latency_ping: (timestamp: number) => void;
//    request_restream_session: () => void;
//   // NEW: Event for the client to start a restream session
//   start_restream: (data: {
//     streamToYouTube: boolean;
//     youtubeStreamKey?: string;
//     streamToFacebook: boolean;
//     facebookStreamKey?: string;
//   }) => void;
//   // NEW: Event to stop a restream session
//   stop_restream: () => void;
//   'restream:start': (data: {
//     platform: 'youtube' | 'twitch' | 'custom';
//     rtmpUrl: string;
//     streamKey: string;
//   }) => void;
//   'restream:stop': () => void;
//   startPreview: (streamKey: string) => void;
//   streamData: (streamKey: string, data: ArrayBuffer) => void;
//   startRestream: (destination: RestreamDestination) => void;
//   stopRestream: (destinationId: string) => void;
// }


// // server/src/types.ts

// import { Socket } from "socket.io";

// // New types for Restreaming
// export interface RestreamDestination {
//   id: string; // a unique ID for the destination, generated by the client
//   name: string;
//   platform: 'YouTube' | 'Facebook' | 'Twitch' | 'Custom';
//   rtmpUrl: string;
//   streamKey: string;
// }

// export type RestreamStatus = 'idle' | 'streaming' | 'error' | 'stopped';

// export interface RestreamState extends RestreamDestination {
//   status: RestreamStatus;
//   message?: string;
// }


// // Existing and new events
// export interface ServerToClientEvents {
//   // Browser Streaming events (if you keep them)
//   browserStreamOffer: (offer: RTCSessionDescriptionInit) => void;
//   browserStreamAnswer: (answer: RTCSessionDescriptionInit) => void;
//   browserStreamIceCandidate: (candidate: RTCIceCandidateInit) => void;
  
//   // Restreaming events
//   rtmpKey: (key: string) => void;
//   obsStreamStatus: (status: { live: boolean; hlsUrl?: string }) => void;
//   restreamUpdate: (update: RestreamState) => void;
// }

// export interface ClientToServerEvents {
//   // Browser Streaming events
//   browserStreamOffer: (socketId: string, offer: RTCSessionDescriptionInit) => void;
//   browserStreamAnswer: (socketId: string, answer: RTCSessionDescriptionInit) => void;
//   browserStreamIceCandidate: (socketId: string, candidate: RTCIceCandidateInit) => void;

//   // Restreaming events
//   requestRtmpKey: () => void;
//   startRestream: (destination: RestreamDestination) => void;
//   stopRestream: (destinationId: string) => void;
// }

// // Keep these as they are
// export interface InterServerEvents {}
// export interface SocketData {}

// export type AppSocket = Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>;

// server/src/types.ts

// import Socket

export interface RestreamDestination {
  id: string;
  name: string;
  platform: 'YouTube' | 'Facebook' | 'Twitch' | 'Custom';
  rtmpUrl: string;
  streamKey: string;
}

export type RestreamStatus = 'idle' | 'streaming' | 'error' | 'stopped';

export interface RestreamState extends RestreamDestination {
  status: RestreamStatus;
  message?: string;
}

export interface ServerToClientEvents {
  rtmpKey: (key: string) => void;
  obsStreamStatus: (status: { live: boolean }) => void; // Simplified: just a boolean
  previewStatus: (status: { live: boolean; hlsUrl?: string }) => void; // New event for preview
  restreamUpdate: (update: RestreamState) => void;
}

export interface ClientToServerEvents {
  startPreview: () => void; // New event
  stopPreview: () => void; // New event
  startRestream: (destination: RestreamDestination) => void;
  stopRestream: (destinationId: string) => void;
}

export interface InterServerEvents {}
export interface SocketData {}

// export type AppSocket = Socket<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>;